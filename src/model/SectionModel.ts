// Copyright 2025 The MathWorks, Inc.

import * as vscode from 'vscode';
import Notification from '../Notifications'
import LineRangeTree from './LineRangeTree';
import { Notifier, Disposer } from '../commandwindow/Utilities';
import { EventEmitter } from 'events';

export interface SectionsData {
    uri: string
    sectionRanges: vscode.Range[]
    sectionsTree?: LineRangeTree
    isDirty?: boolean
}

export class SectionModel extends Disposer {
    private readonly _sectionsCacheByPath = new Map<string, SectionsData>();
    eventEmitter = new EventEmitter()

    initialize (client: Notifier): void {
        this.own(client.onNotification(Notification.MatlabSections, (data) => this._onNewSectionsGenerated(data)))

        this.own(vscode.workspace.onDidChangeTextDocument((event) => this._onDocumentChange(event)));
        this.own(vscode.workspace.onDidCloseTextDocument((document: vscode.TextDocument) => this._onDocumentClose(document)));
    }

    getSectionsForFile (uri: vscode.Uri): SectionsData | undefined {
        return this._sectionsCacheByPath.get(this._getDecodedURI(uri))
    }

    private _onDocumentChange (event: vscode.TextDocumentChangeEvent): void {
        const filePath = decodeURIComponent(event.document.uri.toString());
        const sectionCache = this._sectionsCacheByPath.get(filePath);
        if (sectionCache === undefined || event.contentChanges.length === 0) {
            return
        }
        // As content changes enable isDirty flag, so cursor changes will not renders sections with cache.
        // This flag will reset once the sections are regenerated by matlab
        sectionCache.isDirty = true;
    }

    private _onNewSectionsGenerated (sectionsData: SectionsData): void {
        const decodedUri = decodeURIComponent(sectionsData.uri);
        const editor: vscode.TextEditor | undefined = vscode.window.visibleTextEditors.find((editor) => {
            const textEditorURI = this._getDecodedURI(editor.document.uri)
            return textEditorURI === decodedUri;
        });

        if (editor === undefined) {
            return
        }

        sectionsData.sectionRanges.sort((a: vscode.Range, b: vscode.Range) => a.start.line - b.start.line);
        sectionsData.sectionsTree = new LineRangeTree(sectionsData.sectionRanges);
        sectionsData.isDirty = false;

        this._sectionsCacheByPath.set(decodedUri, sectionsData);

        this.eventEmitter.emit('onSectionsUpdated', { sectionsData, editor });
    }

    private _onDocumentClose (document: vscode.TextDocument): void {
        // Remove sections from cache when document is closed
        const decodedURI = decodeURIComponent(document.uri.toString());
        this._sectionsCacheByPath.delete(decodedURI);
    }

    private _getDecodedURI (uri: vscode.Uri): string {
        return decodeURIComponent(uri.toString())
    }
}
